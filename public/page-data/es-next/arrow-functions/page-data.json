{"componentChunkName":"component---src-templates-blog-post-js","path":"/es-next/arrow-functions/","result":{"data":{"site":{"siteMetadata":{"title":"@kirankumarambati","author":"Kirankumar Ambati","siteUrl":"https://kirankumarambati.me","social":{"twitter":"_sudo_user"}}},"markdownRemark":{"id":"c9fdb4f1-e23a-59d3-9be8-f2d6dbc33d6b","excerpt":"Arrow functions or the FAT arrow functions were introduced as a part of ES6. Along with making a regular function more concise, it has more features added to it…","html":"<p>Arrow functions or the <strong>FAT</strong> arrow functions were introduced as a part of ES6. Along with making a regular function more concise, it has more features added to it. Let’s dive deep into them in this article.</p>\n<h1>tl;dr</h1>\n<p>Functions are mainly used in 3 ways:</p>\n<ol>\n<li>Object methods</li>\n<li>Non-methods</li>\n<li>Constructors</li>\n</ol>\n<blockquote>\n<p>Use regular functions for methods and constructors. Use arrow functions for non-methods. In other words, arrow functions are to be used when we need lexical <strong><code class=\"language-text\">this</code></strong> and regular functions are to be used when we need dynamic <code class=\"language-text\">this</code></p>\n</blockquote>\n<p>Lets get into details</p>\n<h2>Syntax</h2>\n<p>Arrow functions have a concise syntax and make the function more easy to read.</p>\n<p>Eg:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">users<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>vs</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">users<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">user</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Usage of arrow function with parameters:</h3>\n<p><strong>No param:</strong></p>\n<p><code class=\"language-text\">() =&gt; {} // paranthesis are mandatory</code></p>\n<p><strong>One param:</strong></p>\n<p><code class=\"language-text\">(param) =&gt; {}</code>   </p>\n<p><em>OR</em> </p>\n<p><code class=\"language-text\">param =&gt; {} // paranthesis are optional here</code></p>\n<p><strong>More than one param:</strong></p>\n<p><code class=\"language-text\">(param1, param2) =&gt; {} // paranthesis are mandatory</code></p>\n<h3>Implicit VS Explicit return:</h3>\n<p>Using arrow functions, we can return the required value from a function in two different ways: implicit and explicit.</p>\n<ol>\n<li>Implicit return: </li>\n</ol>\n<p><code class=\"language-text\">var x = () =&gt; 2 // Value 2 is returned from function implicitly when invoked without us writing a return statement</code></p>\n<ol start=\"2\">\n<li>Explicit return:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">x</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// explicitly returning 2.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Apart from having the concise method syntax, an arrow function do NOT have access to <code class=\"language-text\">this</code>, <code class=\"language-text\">arguments</code>, <code class=\"language-text\">super</code> and <code class=\"language-text\">new.target</code> inside it. No need of binding <code class=\"language-text\">this</code> to a method while invoking it is a boon as well as a bane depending on the place where an arrow function is used.</p>\n<h3>Advantages</h3>\n<ol>\n<li>No need to bind <code class=\"language-text\">this</code></li>\n<li>Methods are concise and easier to understand</li>\n</ol>\n<h4>Pitfalls:</h4>\n<ol>\n<li>We can <strong>NOT</strong> return a JS object implicitly. </li>\n</ol>\n<p>ie. <code class=\"language-text\">() =&gt; {} // This fails since this signature is same as the empty function with explicit return.</code></p>\n<p>To make it work as expected, the returning object has to be wrapped within paranthesis. The function signature look like:</p>\n<p><code class=\"language-text\">() =&gt; ({}) // this works as expected</code></p>\n<ol start=\"2\">\n<li>Arrows functions can <strong>NOT</strong> be used as object methods.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> character1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    lives<span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">hitObject</span><span class=\"token operator\">:</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lives<span class=\"token operator\">--</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\ncharacter1<span class=\"token punctuation\">.</span><span class=\"token function\">hitObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>character1<span class=\"token punctuation\">)</span> <span class=\"token comment\">// {lives: 9, hitObject: f}</span>\n\n\n<span class=\"token keyword\">var</span> character2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    lives<span class=\"token operator\">:</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function-variable function\">hitObject</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lives<span class=\"token operator\">--</span>\n<span class=\"token punctuation\">}</span>\n\ncharacter2<span class=\"token punctuation\">.</span><span class=\"token function\">hitObject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>character2<span class=\"token punctuation\">)</span> <span class=\"token comment\">// {lives: 10, hitObject: f}</span></code></pre></div>\n<p>The logged output in the second case is different from expected. This happens because <code class=\"language-text\">this</code> binding in arrow function happens differently than in the regular functions.</p>\n<p>In regular function, <code class=\"language-text\">this</code> is determined by the context of the function call. ie. <code class=\"language-text\">this</code> inside hitObject method points to <code class=\"language-text\">character1</code> object when invoked as <code class=\"language-text\">character1.hitObject()</code>. But in the second case, <code class=\"language-text\">this</code> is not pointed <code class=\"language-text\">character2</code>, instead it points to <code class=\"language-text\">Window</code> object. <code class=\"language-text\">this</code>, in case of arrow function, is determined by the lexical scope where the object is declared ie. global <code class=\"language-text\">Window</code></p>\n<ol start=\"3\">\n<li>Arrow functions can <strong>NOT</strong> be used as constructors.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">PersonNormal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">PersonNormal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// returns an empty object {}</span></code></pre></div>\n<p>The above lines works perfectly well. But the below code doesn’t.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">PersonArrow</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">PersonArrow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Uncaught TypeError: PersonArrow is not a constructor</span></code></pre></div>\n<p>The <code class=\"language-text\">new</code> keyword failed because arrow functions do <strong>NOT</strong> have __ <strong>proto</strong> __ and hence they don’t support inheritance. To verify this fact, <code class=\"language-text\">console.log(PersonArrow.prototype)</code> and verify. The output will be <code class=\"language-text\">undefined</code>.</p>\n<ol start=\"4\">\n<li><code class=\"language-text\">yield</code> can <strong>NOT</strong> be used within an arrow function and hence arrow functions can <strong>NOT</strong> be used as <code class=\"language-text\">generators</code></li>\n<li>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">fun</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c</span><span class=\"token punctuation\">)</span>\n        <span class=\"token operator\">=></span> <span class=\"token number\">7</span></code></pre></div>\n</li>\n</ol>\n<p>The above code fails. Instead, the splitting can be done as:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">fun</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token parameter\">a<span class=\"token punctuation\">,</span>\n    b<span class=\"token punctuation\">,</span>\n    c</span>\n<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">7</span></code></pre></div>\n<p><strong>Note:</strong> This is done by keeping the future improvements in mind. It is expected that ‘headless’ arrow functions may be introduced in the later versions of JavaScript. ie. We may have arrow functions that look like </p>\n<p><code class=\"language-text\">=&gt; 2 // No params</code></p>\n<p>If that is the case, the above example </p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">fun</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">,</span> c</span><span class=\"token punctuation\">)</span>\n            <span class=\"token operator\">=></span> <span class=\"token number\">7</span></code></pre></div>\n<p>will be interpreted differently and the code becomes buggy. Hence, the restriction.</p>\n<ol start=\"6\">\n<li>The arrow function has an ‘arrow’. Hence, it has to be used with some extra caution when used with other operators.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token comment\">// Uncaught SyntaxError: Malformed arrow function parameter list</span>\n\n<span class=\"token keyword\">typeof</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// function</span></code></pre></div>\n<p>In case 1, typeof has higher precedence than = and hence execution happens differently than expected. To avoid that, we have to wrap the arrow function in paranthesis, as in case 2.</p>\n<ol start=\"7\">\n<li>Arrow functions are <strong>anonymous</strong>. Hence, they are:</li>\n</ol>\n<p>a. Harder debugging.</p>\n<p>b. No-self referencing.</p>\n<p>Thank you for making till the end of this lengthy article.</p>\n<p>If you enjoy this article, please express your LOVE by liking it and sharing it to others. That keeps me motivated and helps me in writing more such articles. Thank you!</p>","frontmatter":{"title":"ES Next Series - 2. The FAT Arrow","date":"April 09, 2019","tags":["JavaScript","JS","ES6","ES7","ES8","ESNext","Arrow Functions","Usage of Arrow Functions","FAT Arrow Functions","Latest feature of JavaScript","Latest feature of ECMAScript"]}}},"pageContext":{"slug":"/es-next/arrow-functions/","previous":{"fields":{"slug":"/es-next/introduction/"},"frontmatter":{"title":"ES Next Series - 1. Introduction"}},"next":{"fields":{"slug":"/es-next/var-let-constant/"},"frontmatter":{"title":"ES Next Series - 3. var, let or const ?"}}}}}